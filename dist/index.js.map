{
  "version": 3,
  "sources": ["../lib/main.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isnan = require( '@stdlib/math-base-assert-is-nan' );\nvar SIGN_MASK = require( '@stdlib/constants-float64-high-word-sign-mask' );\nvar toWords = require( '@stdlib/number-float64-base-to-words' ).assign;\nvar Uint32Array = require( '@stdlib/array-uint32' );\n\n\n// VARIABLES //\n\nvar WX = new Uint32Array( 2 ); // WARNING: not thread safe\nvar WY = new Uint32Array( 2 );\nvar WZ = new Uint32Array( 2 );\n\n// 2^32:\nvar TWO_32 = 4294967296;\n\n\n// FUNCTIONS //\n\n/**\n* Converts the high and low words of a double-precision floating-point number to a lexicographically ordered integer.\n*\n* ## Notes\n*\n* -   This function mutates the input array.\n*\n* @private\n* @param {Array<integer>} words - high and low words\n* @returns {Array<integer>} input array\n*/\nfunction monotoneKey( words ) {\n\tif ( words[ 0 ]&SIGN_MASK ) { // x < 0\n\t\twords = negate( words ); // maps -\u221E to 0\n\t} else { // x >= 0\n\t\twords[ 0 ] |= SIGN_MASK; // push +0 to just above -0\n\t}\n\treturn words;\n}\n\n/**\n* Perform two's-complement negation.\n*\n* ## Notes\n*\n* -   This function mutates the input array.\n*\n* @private\n* @param {Array<integer>} words - high and low words\n* @returns {Array<integer>} input array\n*/\nfunction negate( words ) {\n\twords[ 0 ] = ~words[ 0 ];\n\twords[ 1 ] = ~words[ 1 ];\n\twords[ 1 ] += 1;\n\n\t// Handle the carry into the high word...\n\tif ( words[ 1 ] === 0 ) {\n\t\twords[ 0 ] += 1;\n\t}\n\treturn words;\n}\n\n/**\n* Returns the ordering of two double-precision floating-point numbers according to their lexicographically ordered high and low words.\n*\n* @private\n* @param {Array<integer>} wa - high and low words for first value\n* @param {Array<integer>} wb - high and low words for second value\n* @returns {integer} relative ordering\n*/\nfunction compare( wa, wb ) {\n\tif ( wa[ 0 ] > wb[ 0 ] ) {\n\t\treturn 1;\n\t}\n\tif ( wa[ 0 ] < wb[ 0 ] ) {\n\t\treturn -1;\n\t}\n\tif ( wa[ 1 ] > wb[ 1 ] ) {\n\t\treturn 1;\n\t}\n\tif ( wa[ 1 ] < wb[ 1 ] ) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/**\n* Performs double-word subtraction.\n*\n* @private\n* @param {Array<integer>} wa - high and low words for first value\n* @param {Array<integer>} wb - high and low words for second value\n* @param {Array<integer>} wc - output array\n* @returns {Array<integer>} output array\n*/\nfunction subtract( wa, wb, wc ) {\n\tvar ha;\n\tvar hb;\n\tvar la;\n\tvar lb;\n\n\tha = wa[ 0 ];\n\tla = wa[ 1 ];\n\thb = wb[ 0 ];\n\tlb = wb[ 1 ];\n\n\tif ( la >= lb ) {\n\t\twc[ 0 ] = ha - hb;\n\t\twc[ 1 ] = la - lb;\n\t} else {\n\t\twc[ 0 ] = ( ha - hb - 1 );      // wrap\n\t\twc[ 1 ] = ( la + TWO_32 ) - lb; // borrow\n\t}\n\treturn wc;\n}\n\n\n// MAIN //\n\n/**\n* Computes the number of representable double-precision floating-point values that separate two double-precision floating-point numbers along the real number line.\n*\n* ## Notes\n*\n* -   Adjacent double-precision floating-point numbers differ by 1 ulp (unit in the last place).\n* -   Signed zeros differ only in the sign bit but are considered numerically equal, and thus their ULP difference is 0.\n*\n* @param {number} x - first value\n* @param {number} y - second value\n* @returns {number} result\n*\n* @example\n* var EPS = require( '@stdlib/constants-float64-eps' );\n*\n* var d = ulpdiff( 1.0, 1.0+EPS );\n* // returns 1.0\n*\n* d = ulpdiff( 1.0+EPS, 1.0 );\n* // returns 1.0\n*\n* d = ulpdiff( 1.0, 1.0+EPS+EPS );\n* // returns 2.0\n*\n* d = ulpdiff( 1.0, NaN );\n* // returns NaN\n*\n* d = ulpdiff( NaN, 1.0 );\n* // returns NaN\n*\n* d = ulpdiff( NaN, NaN );\n* // returns NaN\n*/\nfunction ulpdiff( x, y ) {\n\tvar ord;\n\tvar wx;\n\tvar wy;\n\tvar wz;\n\tif ( isnan( x ) || isnan( y ) ) {\n\t\treturn NaN;\n\t}\n\t// Convert input values to high and low words:\n\twx = toWords( x, WX, 1, 0 );\n\twy = toWords( y, WY, 1, 0 );\n\n\t// Convert the values to lexicographically ordered integers:\n\twx = monotoneKey( wx );\n\twy = monotoneKey( wy );\n\n\t// Determine the relative ordering of the two values so that we always subtract the smaller value from the larger value and ensure that the result is always >= 0:\n\tord = compare( wx, wy );\n\n\t// Perform subtraction...\n\tif ( ord === 0 ) {\n\t\t// Identical encoding:\n\t\treturn 0;\n\t}\n\tif ( ord === 1 ) {\n\t\twz = subtract( wx, wy, WZ );\n\t} else { // ord === -1\n\t\twz = subtract( wy, wx, WZ );\n\t}\n\t// Return a double as a result, which is fine for \u22642^53 ulps:\n\treturn ( wz[ 0 ]*TWO_32 ) + wz[ 1 ];\n}\n\n\n// EXPORTS //\n\nmodule.exports = ulpdiff;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Compute the number of representable double-precision floating-point values that separate two double-precision floating-point numbers along the real number line.\n*\n* @module @stdlib/number-float64-base-ulp-difference\n*\n* @example\n* var EPS = require( '@stdlib/constants-float64-eps' );\n* var ulpdiff = require( '@stdlib/number-float64-base-ulp-difference' );\n*\n* var d = ulpdiff( 1.0, 1.0+EPS );\n* // returns 1.0\n*\n* d = ulpdiff( 1.0+EPS, 1.0 );\n* // returns 1.0\n*\n* d = ulpdiff( 1.0, 1.0+EPS+EPS );\n* // returns 2.0\n*\n* d = ulpdiff( 1.0, NaN );\n* // returns NaN\n*\n* d = ulpdiff( NaN, 1.0 );\n* // returns NaN\n*\n* d = ulpdiff( NaN, NaN );\n* // returns NaN\n*/\n\n// MODULES //\n\nvar main = require( './main.js' );\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],
  "mappings": "uGAAA,IAAAA,EAAAC,EAAA,SAAAC,EAAAC,EAAA,cAsBA,IAAIC,EAAQ,QAAS,iCAAkC,EACnDC,EAAY,QAAS,+CAAgD,EACrEC,EAAU,QAAS,sCAAuC,EAAE,OAC5DC,EAAc,QAAS,sBAAuB,EAK9CC,EAAK,IAAID,EAAa,CAAE,EACxBE,EAAK,IAAIF,EAAa,CAAE,EACxBG,EAAK,IAAIH,EAAa,CAAE,EAGxBI,EAAS,WAgBb,SAASC,EAAaC,EAAQ,CAC7B,OAAKA,EAAO,CAAE,EAAER,EACfQ,EAAQC,EAAQD,CAAM,EAEtBA,EAAO,CAAE,GAAKR,EAERQ,CACR,CAaA,SAASC,EAAQD,EAAQ,CACxB,OAAAA,EAAO,CAAE,EAAI,CAACA,EAAO,CAAE,EACvBA,EAAO,CAAE,EAAI,CAACA,EAAO,CAAE,EACvBA,EAAO,CAAE,GAAK,EAGTA,EAAO,CAAE,IAAM,IACnBA,EAAO,CAAE,GAAK,GAERA,CACR,CAUA,SAASE,EAASC,EAAIC,EAAK,CAC1B,OAAKD,EAAI,CAAE,EAAIC,EAAI,CAAE,EACb,EAEHD,EAAI,CAAE,EAAIC,EAAI,CAAE,EACb,GAEHD,EAAI,CAAE,EAAIC,EAAI,CAAE,EACb,EAEHD,EAAI,CAAE,EAAIC,EAAI,CAAE,EACb,GAED,CACR,CAWA,SAASC,EAAUF,EAAIC,EAAIE,EAAK,CAC/B,IAAIC,EACAC,EACAC,EACAC,EAEJ,OAAAH,EAAKJ,EAAI,CAAE,EACXM,EAAKN,EAAI,CAAE,EACXK,EAAKJ,EAAI,CAAE,EACXM,EAAKN,EAAI,CAAE,EAENK,GAAMC,GACVJ,EAAI,CAAE,EAAIC,EAAKC,EACfF,EAAI,CAAE,EAAIG,EAAKC,IAEfJ,EAAI,CAAE,EAAMC,EAAKC,EAAK,EACtBF,EAAI,CAAE,EAAMG,EAAKX,EAAWY,GAEtBJ,CACR,CAsCA,SAASK,EAASC,EAAGC,EAAI,CACxB,IAAIC,EACAC,EACAC,EACAC,EACJ,OAAK1B,EAAOqB,CAAE,GAAKrB,EAAOsB,CAAE,EACpB,KAGRE,EAAKtB,EAASmB,EAAGjB,EAAI,EAAG,CAAE,EAC1BqB,EAAKvB,EAASoB,EAAGjB,EAAI,EAAG,CAAE,EAG1BmB,EAAKhB,EAAagB,CAAG,EACrBC,EAAKjB,EAAaiB,CAAG,EAGrBF,EAAMZ,EAASa,EAAIC,CAAG,EAGjBF,IAAQ,EAEL,GAEHA,IAAQ,EACZG,EAAKZ,EAAUU,EAAIC,EAAInB,CAAG,EAE1BoB,EAAKZ,EAAUW,EAAID,EAAIlB,CAAG,EAGlBoB,EAAI,CAAE,EAAEnB,EAAWmB,EAAI,CAAE,GACnC,CAKA3B,EAAO,QAAUqB,IC/JjB,IAAIO,EAAO,IAKX,OAAO,QAAUA",
  "names": ["require_main", "__commonJSMin", "exports", "module", "isnan", "SIGN_MASK", "toWords", "Uint32Array", "WX", "WY", "WZ", "TWO_32", "monotoneKey", "words", "negate", "compare", "wa", "wb", "subtract", "wc", "ha", "hb", "la", "lb", "ulpdiff", "x", "y", "ord", "wx", "wy", "wz", "main"]
}
