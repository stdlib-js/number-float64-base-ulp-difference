{"version":3,"file":"index.mjs","sources":["../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isnan from '@stdlib/math-base-assert-is-nan';\nimport SIGN_MASK from '@stdlib/constants-float64-high-word-sign-mask';\nimport { assign as toWords } from '@stdlib/number-float64-base-to-words';\nimport Uint32Array from '@stdlib/array-uint32';\n\n\n// VARIABLES //\n\nvar WX = new Uint32Array( 2 ); // WARNING: not thread safe\nvar WY = new Uint32Array( 2 );\nvar WZ = new Uint32Array( 2 );\n\n// 2^32:\nvar TWO_32 = 4294967296;\n\n\n// FUNCTIONS //\n\n/**\n* Converts the high and low words of a double-precision floating-point number to a lexicographically ordered integer.\n*\n* ## Notes\n*\n* -   This function mutates the input array.\n*\n* @private\n* @param {Array<integer>} words - high and low words\n* @returns {Array<integer>} input array\n*/\nfunction monotoneKey( words ) {\n\tif ( words[ 0 ]&SIGN_MASK ) { // x < 0\n\t\twords = negate( words ); // maps -∞ to 0\n\t} else { // x >= 0\n\t\twords[ 0 ] |= SIGN_MASK; // push +0 to just above -0\n\t}\n\treturn words;\n}\n\n/**\n* Perform two's-complement negation.\n*\n* ## Notes\n*\n* -   This function mutates the input array.\n*\n* @private\n* @param {Array<integer>} words - high and low words\n* @returns {Array<integer>} input array\n*/\nfunction negate( words ) {\n\twords[ 0 ] = ~words[ 0 ];\n\twords[ 1 ] = ~words[ 1 ];\n\twords[ 1 ] += 1;\n\n\t// Handle the carry into the high word...\n\tif ( words[ 1 ] === 0 ) {\n\t\twords[ 0 ] += 1;\n\t}\n\treturn words;\n}\n\n/**\n* Returns the ordering of two double-precision floating-point numbers according to their lexicographically ordered high and low words.\n*\n* @private\n* @param {Array<integer>} wa - high and low words for first value\n* @param {Array<integer>} wb - high and low words for second value\n* @returns {integer} relative ordering\n*/\nfunction compare( wa, wb ) {\n\tif ( wa[ 0 ] > wb[ 0 ] ) {\n\t\treturn 1;\n\t}\n\tif ( wa[ 0 ] < wb[ 0 ] ) {\n\t\treturn -1;\n\t}\n\tif ( wa[ 1 ] > wb[ 1 ] ) {\n\t\treturn 1;\n\t}\n\tif ( wa[ 1 ] < wb[ 1 ] ) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/**\n* Performs double-word subtraction.\n*\n* @private\n* @param {Array<integer>} wa - high and low words for first value\n* @param {Array<integer>} wb - high and low words for second value\n* @param {Array<integer>} wc - output array\n* @returns {Array<integer>} output array\n*/\nfunction subtract( wa, wb, wc ) {\n\tvar ha;\n\tvar hb;\n\tvar la;\n\tvar lb;\n\n\tha = wa[ 0 ];\n\tla = wa[ 1 ];\n\thb = wb[ 0 ];\n\tlb = wb[ 1 ];\n\n\tif ( la >= lb ) {\n\t\twc[ 0 ] = ha - hb;\n\t\twc[ 1 ] = la - lb;\n\t} else {\n\t\twc[ 0 ] = ( ha - hb - 1 );      // wrap\n\t\twc[ 1 ] = ( la + TWO_32 ) - lb; // borrow\n\t}\n\treturn wc;\n}\n\n\n// MAIN //\n\n/**\n* Computes the number of representable double-precision floating-point values that separate two double-precision floating-point numbers along the real number line.\n*\n* ## Notes\n*\n* -   Adjacent double-precision floating-point numbers differ by 1 ulp (unit in the last place).\n* -   Signed zeros differ only in the sign bit but are considered numerically equal, and thus their ULP difference is 0.\n*\n* @param {number} x - first value\n* @param {number} y - second value\n* @returns {number} result\n*\n* @example\n* import EPS from '@stdlib/constants-float64-eps';\n*\n* var d = ulpdiff( 1.0, 1.0+EPS );\n* // returns 1.0\n*\n* d = ulpdiff( 1.0+EPS, 1.0 );\n* // returns 1.0\n*\n* d = ulpdiff( 1.0, 1.0+EPS+EPS );\n* // returns 2.0\n*\n* d = ulpdiff( 1.0, NaN );\n* // returns NaN\n*\n* d = ulpdiff( NaN, 1.0 );\n* // returns NaN\n*\n* d = ulpdiff( NaN, NaN );\n* // returns NaN\n*/\nfunction ulpdiff( x, y ) {\n\tvar ord;\n\tvar wx;\n\tvar wy;\n\tvar wz;\n\tif ( isnan( x ) || isnan( y ) ) {\n\t\treturn NaN;\n\t}\n\t// Convert input values to high and low words:\n\twx = toWords( x, WX, 1, 0 );\n\twy = toWords( y, WY, 1, 0 );\n\n\t// Convert the values to lexicographically order integers:\n\twx = monotoneKey( wx );\n\twy = monotoneKey( wy );\n\n\t// Determine the relative ordering of the two values so that we always subtract the smaller value from the larger value and ensure that the result is always >= 0:\n\tord = compare( wx, wy );\n\n\t// Perform subtraction...\n\tif ( ord === 0 ) {\n\t\t// Identical encoding:\n\t\treturn 0;\n\t}\n\tif ( ord === 1 ) {\n\t\twz = subtract( wx, wy, WZ );\n\t} else { // ord === -1\n\t\twz = subtract( wy, wx, WZ );\n\t}\n\t// Return a double as a result, which is fine for ≤2^53 ulps:\n\treturn ( wz[ 0 ]*TWO_32 ) + wz[ 1 ];\n}\n\n\n// EXPORTS //\n\nexport default ulpdiff;\n"],"names":["WX","Uint32Array","WY","WZ","TWO_32","monotoneKey","words","SIGN_MASK","negate","subtract","wa","wb","wc","ha","hb","la","lb","ulpdiff","x","y","ord","wx","wy","wz","isnan","NaN","toWords"],"mappings":";;0ZA8BA,IAAIA,EAAK,IAAIC,EAAa,GACtBC,EAAK,IAAID,EAAa,GACtBE,EAAK,IAAIF,EAAa,GAGtBG,EAAS,WAgBb,SAASC,EAAaC,GAMrB,OALKA,EAAO,GAAIC,EACfD,EAkBF,SAAiBA,GAChBA,EAAO,IAAOA,EAAO,GACrBA,EAAO,IAAOA,EAAO,GACrBA,EAAO,IAAO,EAGM,IAAfA,EAAO,KACXA,EAAO,IAAO,GAEf,OAAOA,CACR,CA5BUE,CAAQF,GAEhBA,EAAO,IAAOC,EAERD,CACR,CA0DA,SAASG,EAAUC,EAAIC,EAAIC,GAC1B,IAAIC,EACAC,EACAC,EACAC,EAcJ,OAZAH,EAAKH,EAAI,GACTK,EAAKL,EAAI,GACTI,EAAKH,EAAI,GAGJI,IAFLC,EAAKL,EAAI,KAGRC,EAAI,GAAMC,EAAKC,EACfF,EAAI,GAAMG,EAAKC,IAEfJ,EAAI,GAAQC,EAAKC,EAAK,EACtBF,EAAI,GAAQG,EAAKX,EAAWY,GAEtBJ,CACR,CAsCA,SAASK,EAASC,EAAGC,GACpB,IAAIC,EACAC,EACAC,EACAC,EAtFab,EAAIC,EAuFrB,OAAKa,EAAON,IAAOM,EAAOL,GAClBM,KAGRJ,EAAKK,EAASR,EAAGlB,EAAI,EAAG,GACxBsB,EAAKI,EAASP,EAAGjB,EAAI,EAAG,GAGxBmB,EAAKhB,EAAagB,GAClBC,EAAKjB,EAAaiB,GAhGGX,EAmGFW,EAGN,KAHbF,GAnGiBV,EAmGFW,GAlGN,GAAMV,EAAI,GACX,EAEHD,EAAI,GAAMC,EAAI,IACV,EAEJD,EAAI,GAAMC,EAAI,GACX,EAEHD,EAAI,GAAMC,EAAI,IACV,EAEF,GA2FC,GAGPY,EADY,IAARH,EACCX,EAAUY,EAAIC,EAAInB,GAElBM,EAAUa,EAAID,EAAIlB,IAGX,GAAIC,EAAWmB,EAAI,GACjC"}